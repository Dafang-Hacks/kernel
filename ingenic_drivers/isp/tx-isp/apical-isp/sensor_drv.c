/*-----------------------------------------------------------------------------
  This confidential and proprietary software/information may be used only
  as authorized by a licensing agreement from Apical Limited

  (C) COPYRIGHT 2011 - 2014 Apical Limited
  ALL RIGHTS RESERVED

  The entire notice above must be reproduced on all authorized
  copies and copies may only be made to the extent permitted
  by a licensing agreement from Apical Limited.
  -----------------------------------------------------------------------------*/

/*-----------------------------------------------------------------------------
  Generated by CSRCGEN compiler - do not edit
  -----------------------------------------------------------------------------*/

#include "sensor_drv.h"
#include <apical-isp/apical_types.h>
#include "spi_defs.h"
#include <apical-isp/apical_configuration.h>
#include <apical-isp/apical_calibrations.h>
#include "apical_modulation.h"
#include <apical-isp/system_isp_io.h>
#include "sensor_init.h"
#include <apical-isp/apical_math.h>

EXPORT_SYMBOL(log2_fixed_to_fixed);
EXPORT_SYMBOL(math_exp2);
//-------------------------------------------------------------------------------------

static struct tx_isp_core_device *ispcore = NULL;

//--------------------RESET------------------------------------------------------------
static void sensor_hw_reset_enable(void)
{
	//	printk("^^^ %s ^^^\n",__func__);
	//	system_reset_sensor(0);
}
static void sensor_hw_reset_disable(void)
{
	//	printk("^^^ %s ^^^\n",__func__);
	//	system_reset_sensor(3);
}
//static uint32_t x;
//-------------------------------------------------------------------------------------
static int32_t sensor_alloc_analog_gain(int32_t gain, sensor_context_t *p_ctx)
{
	unsigned int again = 0;
	struct tx_isp_sensor_attribute *attr = ispcore->vin.attr;

	gain = attr->sensor_ctrl.alloc_again(gain, LOG2_GAIN_SHIFT, &again);
	p_ctx->again = again;
	/* printk("result gain is 0x%x\n",again); */
	return gain;
}

static int32_t sensor_alloc_digital_gain(int32_t gain, sensor_context_t *p_ctx)
{
	unsigned int dgain = 0;
	struct tx_isp_sensor_attribute *attr = ispcore->vin.attr;

	gain = attr->sensor_ctrl.alloc_dgain(gain, LOG2_GAIN_SHIFT, &dgain);
	p_ctx->dgain = dgain;
	/* printk("result gain is 0x%x\n",p_ctx->dgain); */
	return gain;
}

static void sensor_alloc_integration_time(uint16_t *int_time, sensor_context_t *p_ctx)
{
	struct tx_isp_sensor_attribute *attr = ispcore->vin.attr;
	//	printk("^^^ %s ^^^\n",__func__);
	if(*int_time < attr->min_integration_time_native)
		*int_time = attr->min_integration_time_native;
	if(*int_time > attr->max_integration_time_native - 1)
		*int_time = attr->max_integration_time_native - 1;
}

static void sensor_set_integration_time(apical_sbus_ptr_t p_sbus, uint16_t int_time, sensor_param_t* param)
{
#if 0
	int32_t expo;
	struct tx_isp_sensor_attribute *attr = ispcore->vin.attr;
	struct v4l2_subdev *sd = &ispcore->sd;
	struct isp_private_ioctl ioctl;
	struct tx_isp_notify_argument arg;

	expo = int_time;
	/* printk("expo is 0x%x,int_time is 0x%x\n",expo,int_time); */

	ioctl.dir = TX_ISP_PRIVATE_IOCTL_SET;
	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_SENSOR_INT_TIME;
	ioctl.value = expo;

	if(ioctl.value != attr->integration_time){
		/* printk("111interation time is 0x%x\n",ioctl.value); */
		attr->integration_time = expo;
		arg.value = (int)&ioctl;
		sd->v4l2_dev->notify(sd, TX_ISP_NOTIFY_PRIVATE_IOCTL, &arg);
	}
#else
	struct tx_isp_sensor_attribute *attr = ispcore->vin.attr;
	if(int_time != attr->integration_time){
		attr->integration_time = int_time;
		ispcore->i2c_msgs[TX_ISP_I2C_SET_INTEGRATION].flag = 1;
		ispcore->i2c_msgs[TX_ISP_I2C_SET_INTEGRATION].value = int_time;
	}
#endif
}

static void sensor_set_analog_gain(apical_sbus_ptr_t p_sbus,uint32_t again_reg_val, sensor_context_t *p_ctx)
{
#if 0
	struct v4l2_subdev *sd = &ispcore->sd;
	struct isp_private_ioctl ioctl;
	struct tx_isp_notify_argument arg;
	struct tx_isp_sensor_attribute *attr = ispcore->vin.attr;
	ioctl.dir = TX_ISP_PRIVATE_IOCTL_SET;
	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_SENSOR_AGAIN;
	ioctl.value = again_reg_val;

	if(ioctl.value != attr->again){
		attr->again = again_reg_val;
		/* printk("set again is 0x%x\n",again_reg_val); */
		arg.value = (int)&ioctl;
		sd->v4l2_dev->notify(sd, TX_ISP_NOTIFY_PRIVATE_IOCTL, &arg);
	}
#else
	struct tx_isp_sensor_attribute *attr = ispcore->vin.attr;
	if(again_reg_val != attr->again){
		attr->again = again_reg_val;
		ispcore->i2c_msgs[TX_ISP_I2C_SET_AGAIN].flag = 1;
		ispcore->i2c_msgs[TX_ISP_I2C_SET_AGAIN].value = again_reg_val;
	}
#endif
}

static void sensor_set_digital_gain(apical_sbus_ptr_t p_sbus, uint32_t dgain_reg_val, sensor_context_t *p_ctx)
{
#if 0
	struct v4l2_subdev *sd = &ispcore->sd;
	struct isp_private_ioctl ioctl;
	struct tx_isp_notify_argument arg;
	ioctl.dir = TX_ISP_PRIVATE_IOCTL_SET;
	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_SENSOR_DGAIN;
	ioctl.value = dgain_reg_val;

	arg.value = (int)&ioctl;
	sd->v4l2_dev->notify(sd, TX_ISP_NOTIFY_PRIVATE_IOCTL, &arg);
#else
	struct tx_isp_sensor_attribute *attr = ispcore->vin.attr;
	if(dgain_reg_val != attr->dgain){
		attr->dgain = dgain_reg_val;
		ispcore->i2c_msgs[TX_ISP_I2C_SET_DGAIN].flag = 1;
		ispcore->i2c_msgs[TX_ISP_I2C_SET_DGAIN].value = dgain_reg_val;
	}
#endif
}

static uint16_t sensor_get_normal_fps(sensor_param_t* param)
{
	unsigned int fps = ispcore->vin.fps;
	return (((fps >> 16) / (fps & 0xffff)) << 8) + ((((fps >> 16) % (fps & 0xffff)) << 8) / (fps & 0xffff));
}

static uint16_t sensor_read_black_pedestal(apical_sbus_ptr_t p_sbus,int i,uint32_t gain)
{
	unsigned int black = 0;
#if USE_BLACK_CALIBRATION
	switch(i)
	{
		case 0: return calc_modulation_u16(gain,  (const modulation_entry_t *)(_GET_USHORT_PTR( _CALIBRATION_BLACK_LEVEL_R_LINEAR)), _GET_ROWS(_CALIBRATION_BLACK_LEVEL_R_LINEAR));
		case 1: return calc_modulation_u16(gain,  (const modulation_entry_t *)(_GET_USHORT_PTR( _CALIBRATION_BLACK_LEVEL_GR_LINEAR)), _GET_ROWS(_CALIBRATION_BLACK_LEVEL_GR_LINEAR));
		case 2: return calc_modulation_u16(gain,  (const modulation_entry_t *)(_GET_USHORT_PTR( _CALIBRATION_BLACK_LEVEL_GB_LINEAR)), _GET_ROWS(_CALIBRATION_BLACK_LEVEL_GB_LINEAR));
		case 3: return calc_modulation_u16(gain,  (const modulation_entry_t *)(_GET_USHORT_PTR( _CALIBRATION_BLACK_LEVEL_B_LINEAR)), _GET_ROWS(_CALIBRATION_BLACK_LEVEL_B_LINEAR));
	}
#else
	struct v4l2_subdev *sd = &ispcore->sd;
	struct isp_private_ioctl ioctl;
	struct tx_isp_notify_argument arg;
	ioctl.dir = TX_ISP_PRIVATE_IOCTL_GET;
	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_SENSOR_BLACK_LEVEL;
	ioctl.value = i;

	arg.value = (int)&ioctl;
	sd->v4l2_dev->notify(sd, TX_ISP_NOTIFY_PRIVATE_IOCTL, &arg);
	if(arg.ret)
		printk("## ERROR: %s[%d] ##\n", __func__,__LINE__);
#endif
	return black;
}

static void sensor_set_mode(apical_sbus_ptr_t p_sbus, uint8_t mode, sensor_param_t* param)
{
	unsigned char tx_mode = TX_ISP_SENSOR_PREVIEW_RES_MAX_FPS;
	struct tx_isp_sensor_attribute *attr = ispcore->vin.attr;
	struct v4l2_mbus_framefmt *mbus = &(ispcore->vin.mbus);
	struct v4l2_subdev *sd = &ispcore->sd;
	struct isp_private_ioctl ioctl;
	struct tx_isp_notify_argument arg;
	if(mode == SENSOR_SEQUENCE_PREVIEW_RES_MAX_FPS){
		tx_mode = TX_ISP_SENSOR_PREVIEW_RES_MAX_FPS;
	}else if(mode == SENSOR_SEQUENCE_FULL_RES_MAX_FPS){
		tx_mode = TX_ISP_SENSOR_FULL_RES_MAX_FPS;
	}else{
		printk("^^^ %s mode(%d) is invalid! ^^^\n",__func__, mode);
		return;
	}
	ioctl.dir = TX_ISP_PRIVATE_IOCTL_SET;
	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_SENSOR_RESIZE;
	ioctl.value = tx_mode;

	arg.value = (int)&ioctl;
	sd->v4l2_dev->notify(sd, TX_ISP_NOTIFY_PRIVATE_IOCTL, &arg);

	param->active.width = mbus->width;
	param->active.height = mbus->height;
	param->total.width = attr->total_width;
	param->total.height = attr->total_height;
	param->integration_time_min = attr->min_integration_time;
	param->integration_time_max = attr->max_integration_time;
	param->integration_time_long_max = attr->max_integration_time;
	param->integration_time_limit = attr->integration_time_limit;
	param->mode = mode;
}

static void sensor_start_changes(apical_sbus_ptr_t p_sbus, sensor_context_t *p_ctx)
{
	struct v4l2_subdev *sd = &ispcore->sd;
	struct isp_private_ioctl ioctl;
	struct tx_isp_notify_argument arg;
	ioctl.dir = TX_ISP_PRIVATE_IOCTL_SET;
	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_SUBDEV_PREPARE_CHANGE;
	return;
	arg.value = (int)&ioctl;
	sd->v4l2_dev->notify(sd, TX_ISP_NOTIFY_PRIVATE_IOCTL, &arg);
	//	printk("^^^ %s ^^^\n",__func__);
	// Does not support this function!
}

static void sensor_end_changes(apical_sbus_ptr_t p_sbus, sensor_context_t *p_ctx)
{
	struct v4l2_subdev *sd = &ispcore->sd;
	struct isp_private_ioctl ioctl;
	struct tx_isp_notify_argument arg;
	ioctl.dir = TX_ISP_PRIVATE_IOCTL_SET;
	ioctl.cmd = TX_ISP_PRIVATE_IOCTL_SUBDEV_FINISH_CHANGE;
	return;
	arg.value = (int)&ioctl;
	sd->v4l2_dev->notify(sd, TX_ISP_NOTIFY_PRIVATE_IOCTL, &arg);
	//	printk("^^^ %s ^^^\n",__func__);
	// Does not support this function!
}

static uint16_t sensor_get_id(apical_sbus_ptr_t p_sbus)
{
	struct tx_isp_sensor_attribute *attr = ispcore->vin.attr;
	return attr->chip_id;
}

static void sensor_set_wdr_mode(apical_sbus_ptr_t p_sbus, uint8_t mode, sensor_param_t* param)
{
	//	printk("^^^ %s ^^^\n",__func__);
	// This sensor does not support native WDR
}

static uint8_t sensor_fps_control(apical_sbus_ptr_t p_sbus, uint8_t fps, sensor_param_t* param)
{
	struct tx_isp_sensor_attribute *attr = ispcore->vin.attr;

	param->total.width = attr->total_width;
	param->total.height = attr->total_height;
	param->integration_time_min = attr->min_integration_time;
	param->integration_time_max = attr->max_integration_time;
	param->integration_time_long_max = attr->max_integration_time;
	param->integration_time_limit = attr->integration_time_limit;
	return ispcore->vin.fps >> 16;
}

static void sensor_disable_isp(apical_sbus_ptr_t p_sbus)
{
}
static uint32_t sensor_get_lines_per_second(apical_sbus_ptr_t p_sbus,sensor_param_t* param)
{
	uint32_t lines_per_second=0;
	return lines_per_second;
}

static inline unsigned int fixed16_add_fixed16(unsigned int f1, unsigned int f2)
{
	unsigned int i = ((f1 >> TX_ISP_GAIN_FIXED_POINT) + (f2 >> TX_ISP_GAIN_FIXED_POINT)) << TX_ISP_GAIN_FIXED_POINT;
	unsigned int p = (f1 & ((1 << TX_ISP_GAIN_FIXED_POINT) - 1)) + (f2 & ((1 << TX_ISP_GAIN_FIXED_POINT) - 1));
	return i + p;
}
//--------------------Initialization------------------------------------------------------------
void sensor_init(sensor_control_t *ctrl)
{
	struct tx_isp_video_in *vin = &ispcore->vin;
	struct tx_isp_sensor_attribute *attr = vin->attr;
	if(attr->cbus_type == TX_SENSOR_CONTROL_INTERFACE_I2C){
		ctrl->sbus.mask = attr->cbus_mask;
		ctrl->sbus.device = attr->cbus_device;
		apical_sbus_i2c_init(&ctrl->sbus);
	}else if(attr->cbus_type == TX_SENSOR_CONTROL_INTERFACE_SPI){
		ctrl->sbus.mask = attr->cbus_mask;
		ctrl->sbus.control = attr->cbus_device;
		apical_sbus_spi_init(&ctrl->sbus);
	}else
		return;

	ctrl->param.again_log2_max = attr->max_again;
	ctrl->param.dgain_log2_max= attr->max_dgain;
	ctrl->param.integration_time_apply_delay = attr->integration_time_apply_delay;
	ctrl->param.analog_gain_apply_delay = attr->again_apply_delay;
	ctrl->param.digital_gain_apply_delay = attr->dgain_apply_delay;
	ctrl->hw_reset_disable = sensor_hw_reset_disable;
	ctrl->hw_reset_enable = sensor_hw_reset_enable;
	ctrl->alloc_analog_gain = sensor_alloc_analog_gain;
	ctrl->alloc_digital_gain = sensor_alloc_digital_gain;
	ctrl->alloc_integration_time = sensor_alloc_integration_time;
	ctrl->set_integration_time = sensor_set_integration_time;
	ctrl->start_changes = sensor_start_changes;
	ctrl->end_changes = sensor_end_changes;
	ctrl->set_analog_gain = sensor_set_analog_gain;
	ctrl->set_digital_gain = sensor_set_digital_gain;
	ctrl->get_normal_fps = sensor_get_normal_fps;
	ctrl->read_black_pedestal = sensor_read_black_pedestal;
	ctrl->set_mode = sensor_set_mode;
	ctrl->set_wdr_mode = sensor_set_wdr_mode;
	ctrl->fps_control = sensor_fps_control;
	ctrl->get_id = sensor_get_id;
	ctrl->disable_isp=sensor_disable_isp;
	ctrl->get_lines_per_second=sensor_get_lines_per_second;
}
//********************CONSTANT SECTION END*********************************************
int apical_sensor_early_init(struct tx_isp_core_device *core)
{
	if(!core)
		return -ISP_ERROR;
	if(!ispcore)
		ispcore = core;
	return ISP_SUCCESS;
}
//*************************************************************************************
